var documenterSearchIndex = {"docs":
[{"location":"api/high-precision-arithmetic/#High-Precision-Arithmetic-API","page":"API","title":"High Precision Arithmetic API","text":"","category":"section"},{"location":"api/high-precision-arithmetic/","page":"API","title":"API","text":"This section details the HighPrecisionArithmetic module.","category":"page"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.HIGH_PRECISION_BASE","page":"API","title":"HighPrecisionArithmetic.HIGH_PRECISION_BASE","text":"HIGH_PRECISION_BASE\n\nThis constant defines the base used for high-precision arithmetic, set to 2^32. \n\nIt efficiently uses the UInt64 type to store 32-bit chunks, enabling safe intermediate operations \n\nlike +, -, and * with carry, without risking overflow during computation.\n\nEach element in the coeffs vector of a HighPrecisionInt represents a digit in this base, \n\nforming the foundation of our custom high-precision number representation.\n\n\n\n\n\n","category":"constant"},{"location":"api/high-precision-arithmetic/#Base.GMP.BigInt-Tuple{HighPrecisionInt}","page":"API","title":"Base.GMP.BigInt","text":"Base.BigInt(hpi::HighPrecisionInt)\n\nConverts a HighPrecisionInt into a BigInt.\n\nIt reconstructs the Big-Integer from its base-HIGH_PRECISION_BASE representation using the formula:\n\ntextBigInt = textsign times sum_i=1^n textcoeff_i times textHIGH_PRECISION_BASE^i-1\n\nwhere textcoeff_i are the coefficients of the HighPrecisionInt and n is the number of coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.HighPrecisionInt","page":"API","title":"HighPrecisionArithmetic.HighPrecisionInt","text":"HighPrecisionInt\n\nA mutable struct representing a high-precision integer.\n\nIt stores integer as an arbitrary length vector of coeffs::Vector{UInt64} coefficients in HIGH_PRECISION_BASE\n\nand a sign::Int8 sign (1 for positive, -1 for negative, 0 for zero).\n\nThe coefficients are stored in little-endian order (least significant coefficient first).\n\nInner constructor\n\nConstructs a HighPrecisionInt and normalizes to ensure a consistent representation based on HIGH_PRECISION_BASE.\n\n\n\n\n\n","category":"type"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.HighPrecisionInt-Tuple{T} where T<:Integer","page":"API","title":"HighPrecisionArithmetic.HighPrecisionInt","text":"HighPrecisionInt(x::T) where {T<:Union{Integer, BigInt}}\n\nCreates a HighPrecisionInt from an Integer or BigInt x, representing it in base-HIGH_PRECISION_BASE.\n\nHere's the breakdown:\n\nHandle Zero: \nIf x is zero, it returns a HighPrecisionInt representing zero directly.\nDetermine Sign: \nIt determines the sign of x (positive, negative).\nExtract Coefficients:  \nFor x compute coefficients c_i where 0 le c_i  textHIGH_PRECISION_BASE such that:\n ``\\sum_{i=1}^{n} c_i \\cdot \\text{HIGH\\_PRECISION\\_BASE}^{i-1} = |x|``\n\n \n using repeated division and remainder: ``c_i = |x| \\mod \\text{HIGH\\_PRECISION\\_BASE}``.\nThis yields the coefficients of the number x in base-HIGH_PRECISION_BASE in little-endian order.\nConstruct and Return: \nFinally, it constructs a HighPrecisionInt using the coefficients and the sign ordered from least to most significant.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.HighPrecisionMatrix","page":"API","title":"HighPrecisionArithmetic.HighPrecisionMatrix","text":"HighPrecisionMatrix\n\nA mutable struct representing a high-precision matrix. It stores a 2D array (Vector of Vectors) of HighPrecisionInt elements.\n\n\n\n\n\n","category":"type"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.HighPrecisionVector","page":"API","title":"HighPrecisionArithmetic.HighPrecisionVector","text":"HighPrecisionVector\n\nA mutable struct representing a high-precision vector. It stores a vector of HighPrecisionInt elements.\n\n\n\n\n\n","category":"type"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{HighPrecisionInt, HighPrecisionInt}","page":"API","title":"Base.:*","text":"Base.:*(a::HighPrecisionInt, b::HighPrecisionInt)\n\nMultiplies two HighPrecisionInt numbers, a and b.\n\nThe method implements long multiplication using base B = 2^32 (HIGH_PRECISION_BASE).\n\nMathematical Foundation\n\nLet a = sum_k=1^textlen_a a_k cdot B^k-1 and b = sum_l=1^textlen_b b_l cdot B^l-1, where a_k = textacoeffsk and b_l = textbcoeffsl are coefficients in base B.\n\nThe product is a cdot b = sum_k=1^textlen_a sum_l=1^textlen_b (a_k cdot b_l) cdot B^k+l-2.\n\nEach partial product p_kl = a_k cdot b_l (a UInt64, prod in code) can be written as p_kl = lo_kl + hi_kl cdot B, where:\n\nlo_kl = p_kl pmod B (lower 32 bits, prod & MASK32)\nhi_kl = lfloor p_kl  B rfloor (upper 32 bits, prod >> 32).\n\nThe term (a_k cdot b_l) cdot B^k+l-2 contributes lo_kl to the coefficient of B^k+l-2 (index k+l-1 in the result vector) and hi_kl to the coefficient of B^k+l-1 (index k+l in the result vector). These contributions are summed up with carries.\n\nAlgorithm Steps\n\nHandle Zero: If atextsign = 0 or btextsign = 0, the result is HighPrecisionInt(0).\nInitialize Result: A zero-filled UInt64 vector result of length len_a + len_b is created,      where len_a and len_b are the lengths of a.coeffs and b.coeffs.\nMultiply and Accumulate with Carry:  For each a_i (a.coeffs[i]) and b_j (b.coeffs[j]):\na.  Compute partial product: p = a_i cdot b_j (a UInt64).\nb.  Split p into 32-bit parts: lo = p pmod B (i.e., p & MASK32), hi = p gg 32.\nc.  Accumulate lo:      At index k = i+j-1:      result[k] \\leftarrow result[k] + lo      carry = result[k] \\gg 32 (extract carry from the sum)      result[k] \\leftarrow result[k] \\pmod B (or result[k] \\&= \\text{MASK32})\nd.  Accumulate hi and carry:      At index k leftarrow k+1 (now i+j):      result[k] \\leftarrow result[k] + hi + \\text{carry}_{\\text{prev_step}}      carry = result[k] \\gg 32      result[k] \\leftarrow result[k] \\pmod B\ne.  Propagate Final Carry:      While carry \\neq 0:      k leftarrow k+1.      result[k] \\leftarrow result[k] + carry      carry_{\\text{new}} = result[k] \\gg 32      result[k] \\leftarrow result[k] \\pmod B      carry \\leftarrow carry_{\\text{new}}\nFinalize: Trim leading zeros from result, set sign as a.sign * b.sign,  and return the HighPrecisionInt.\n\nImplementation Notes\n\nCoefficients a_i b_j  2^32, so their product a_i cdot b_j  2^64 (fits in UInt64).\nAll arithmetic for accumulation and carry uses UInt64    with bitwise operations (& MASK32, >> 32) for efficiency and to prevent overflow.\n@inbounds is used in loops for performance.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{HighPrecisionMatrix, HighPrecisionMatrix}","page":"API","title":"Base.:*","text":"Base.:*(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)\n\nMatrix-matrix multiplication. Number of columns in m1 must equal number of rows in m2. The multiplication and summation are performed using BigInt intermediates to avoid repeated HighPrecisionInt object creation during summation for each element.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{HighPrecisionMatrix, HighPrecisionVector}","page":"API","title":"Base.:*","text":"Base.:*(m::HighPrecisionMatrix, v::HighPrecisionVector)\n\nMatrix-vector multiplication. Number of matrix columns must equal vector length. The multiplication and summation are performed using BigInt intermediates to avoid repeated HighPrecisionInt object creation during summation for each element.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{HighPrecisionMatrix, Union{Integer, HighPrecisionInt}}","page":"API","title":"Base.:*","text":"Base.:*(m::HighPrecisionMatrix, scalar::Union{Integer, BigInt, HighPrecisionInt})\n\nScalar-matrix multiplication (matrix * scalar).\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{HighPrecisionVector, Union{Integer, HighPrecisionInt}}","page":"API","title":"Base.:*","text":"Base.:*(v::HighPrecisionVector, scalar::Union{Integer, BigInt, HighPrecisionInt})\n\nScalar-vector multiplication (vector * scalar).\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{Union{Integer, HighPrecisionInt}, HighPrecisionMatrix}","page":"API","title":"Base.:*","text":"Base.:*(scalar::Union{Integer, BigInt, HighPrecisionInt}, m::HighPrecisionMatrix)\n\nScalar-matrix multiplication (scalar * matrix).\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{Union{Integer, HighPrecisionInt}, HighPrecisionVector}","page":"API","title":"Base.:*","text":"Base.:*(scalar::Union{Integer, BigInt, HighPrecisionInt}, v::HighPrecisionVector)\n\nScalar-vector multiplication (scalar * vector).\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:+-Tuple{HighPrecisionInt, HighPrecisionInt}","page":"API","title":"Base.:+","text":"Base.:+(a::HighPrecisionInt, b::HighPrecisionInt)\n\nAdds two HighPrecisionInt numbers, a and b.\n\nPerforms efficient large-integer addition using sign handling and base-2^32 arithmetic with carry propagation.\n\nMathematical Foundation\n\nLet a = textsign_a cdot a and b = textsign_b cdot b, where coefficients are in base B=2^32.\n\nSame Signs (textsign_a = textsign_b):    The result is textsign_a cdot (a + b) using standard digit-wise addition with carry propagation.\nDifferent Signs (textsign_a neq textsign_b):    The result simplifies to a subtraction of absolute values,        i.e., a + b = pm (a - b), where the pm with sign from the larger operand.       This is handled by an abs_subtract function.\n\nAlgorithm\n\nZero Check: If either a or b is zero, the other operand is returned.\nSame Sign Addition:\nInitialize a result_coeffs vector and carry = 0.\nIterate, summing corresponding coefficients of a b   from left to right (padding with UInt64(0) if needed) and the current carry.\nThe current result digit is (sum) & MASK32 (lower 32 bits),    and the new carry is (sum) >> 32 (upper 32 bits).\nAppend any final carry to result_coeffs.\nThe result inherits the common sign of a and b.\nDifferent Sign Subtraction:\nIf signs differ (e.g., a  0 b  0), abs_subtract(a.coeffs, b.coeffs) (or b.coeffs, a.coeffs if a  0 b  0) is invoked.\nIf the result of abs_subtract indicates a negative difference,   the final sign is negative; otherwise, it's positive.\n\nImplementation Notes\n\nAll arithmetic uses UInt64 with bitwise ops (& MASK32, >> 32) to extract coefficients and carries efficiently. \n@inbounds is used in loops for performance, assuming safe indexing.  \nabs_subtract handles differing signs by computing the absolute difference and its sign.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:+-Tuple{HighPrecisionMatrix, HighPrecisionMatrix}","page":"API","title":"Base.:+","text":"Base.:+(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)\n\nMatrix addition. Both matrices must have the same dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:+-Tuple{HighPrecisionVector, HighPrecisionVector}","page":"API","title":"Base.:+","text":"Base.:+(v1::HighPrecisionVector, v2::HighPrecisionVector)\n\nVector addition. Both vectors must have the same length.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:--Tuple{HighPrecisionInt, HighPrecisionInt}","page":"API","title":"Base.:-","text":"Base.:-(a::HighPrecisionInt, b::HighPrecisionInt)\n\nSubtraction operator for HighPrecisionInt.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:--Tuple{HighPrecisionInt}","page":"API","title":"Base.:-","text":"Base.:-(hpi::HighPrecisionInt)\n\nUnary negation operator for HighPrecisionInt.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:--Tuple{HighPrecisionMatrix, HighPrecisionMatrix}","page":"API","title":"Base.:-","text":"Base.:-(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)\n\nMatrix subtraction. Both matrices must have the same dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:--Tuple{HighPrecisionVector, HighPrecisionVector}","page":"API","title":"Base.:-","text":"Base.:-(v1::HighPrecisionVector, v2::HighPrecisionVector)\n\nVector subtraction. Both vectors must have the same length.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.abs-Tuple{HighPrecisionInt}","page":"API","title":"Base.abs","text":"Base.abs(hpi::HighPrecisionInt)\n\nReturns the absolute value of a HighPrecisionInt.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.isequal-Tuple{HighPrecisionInt, HighPrecisionInt}","page":"API","title":"Base.isequal","text":"Base.isequal(a::HighPrecisionInt, b::HighPrecisionInt)\n\nChecks whether two HighPrecisionInt numbers are equal (a == b).\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.isless-Tuple{HighPrecisionInt, HighPrecisionInt}","page":"API","title":"Base.isless","text":"Base.isless(a::HighPrecisionInt, b::HighPrecisionInt)\n\nCompares two HighPrecisionInt numbers for less than (a < b).\n\nHere's the breakdown:\n\nSign Comparison:\nIf textsign(a) neq textsign(b), then a  b Leftrightarrow textsign(a)  textsign(b).\nIf textsign(a) = textsign(b) = 0, they are equal, so a not b.\nMagnitude Comparison:  Let L_a L_b be the number of coefficients and c_a^k c_b^k be the k-th coefficients (most significant first).\nIf L_a neq L_b:\nFor positive numbers: a  b Leftrightarrow L_a  L_b.\nFor negative numbers: a  b Leftrightarrow L_a  L_b.\nIf L_a = L_b: Compare c_a^k and c_b^k from most significant (k=L_a) downwards.\nFor positive numbers: a  b if the first differing c_a^k  c_b^k.\nFor negative numbers: a  b if the first differing c_a^k  c_b^k.\nIf all coefficients are identical, a=b, so a not b.\nThe code uses a flip flag and XOR (⊻) to implement this logic concisely.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.show-Tuple{IO, HighPrecisionInt}","page":"API","title":"Base.show","text":"Base.show(io::IO, hpi::HighPrecisionInt)\n\nDefines how a HighPrecisionInt is displayed by converting it  to a BigInt for a user-friendly decimal representation and its internal coefficient representation.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.abs_subtract-Tuple{Vector{UInt64}, Vector{UInt64}}","page":"API","title":"HighPrecisionArithmetic.abs_subtract","text":"abs_subtract(a_coeffs::Vector{UInt64}, b_coeffs::Vector{UInt64})\n\nSubtracts the magnitudes of two numbers represented by a_coeffs and b_coeffs (in base B=2^32), effectively computing a - b. Used when adding numbers of different signs in + operator. \n\nReturns a tuple: (result_coeffs, is_negative_diff). result_coeffs is the vector of coefficients representing  a - b . is_negative_diff is true if b  a (i.e., the original difference a - b would be negative). This helper function is primarily used within the main addition/subtraction (+ or - operator overloads for HighPrecisionInt) when the operands have differing signs.\n\nMathematical Foundation\n\nGiven non-negative numbers X Y represented by coefficient vectors a_coeffs and b_coeffs respectively in base B=2^32:\n\nX = sum_k=1^textlength(a_coeffs) texta_coeffsk cdot B^k-1\n\nY = sum_l=1^textlength(b_coeffs) textb_coeffsl cdot B^l-1\n\nThis function computes X - Y by subtracting the smaller magnitude from the larger. If X_k  Y_k + textborrow, a borrow of 1 from the next higher coefficient (effectively adding B to X_k) is performed. The is_negative_diff flag indicates if Y  X.\n\nAlgorithm Steps\n\nDetermine Larger Magnitude:       Compare a_coeffs and b_coeffsby length; if equal, compare the most significant differing digit. Setsamagis_larger`.\nAssign Operands: \nop1_coeffs holds the larger magnitude's coefficients, op2_coeffs the smaller.\nresult_coeffs is sized to match op1_coeffs.\nSubtract with Borrow:\nInitialize borrow = 0. For i = 1 dots textlength(op1_coeffs):\nLet v_1 = textop1_coeffsi and v_2 = (i le textlength(op2_coeffs)  textop2_coeffsi  0).\nIf v_1  v_2 + textborrow:   textresult_coeffsi leftarrow B + v_1 - v_2 - textborrow; textborrow leftarrow 1.\nElse:   textresult_coeffsi leftarrow v_1 - v_2 - textborrow; textborrow leftarrow 0.\nFinalize: \nTrim leading zeros from result_coeffs using resize!. \nIf result is zero, is_negative_diff becomes false.\nReturn (result_coeffs, !a_mag_is_larger).\n\nImplementation Notes\n\n- All coefficient values and intermediate arithmetic (sums, borrows)\n     are handled using `UInt64` to prevent overflow, as coefficients are less than ``2^{32}``.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.normalize!-Tuple{HighPrecisionInt}","page":"API","title":"HighPrecisionArithmetic.normalize!","text":"normalize!(hpi::HighPrecisionInt)\n\nNormalizes a HighPrecisionInt in place, ensuring its internal representation is canonical and efficient.\n\nThis function performs four crucial tasks:\n\nInitial Zero Check\nIf the coefficient vector is empty, the number is initialized to zero by adding a 0 coefficient and setting the sign to 0.\nFixes Carries/Borrows (Digit Overflow)\nFor coefficients c_i, ensure 0 le c_i  textHIGH_PRECISION_BASE by carrying over: c_i leftarrow c_i mod textHIGH_PRECISION_BASE\nRemoves Leading Zeros\nTrims unnecessary most significant zeros to keep the number compact.\nCorrects Signs\nSets sign to 0 if the number is zero; otherwise ensures it's positive if non-zero.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#LinearAlgebra.dot-Tuple{HighPrecisionVector, HighPrecisionVector}","page":"API","title":"LinearAlgebra.dot","text":"LinearAlgebra.dot(v1::HighPrecisionVector, v2::HighPrecisionVector)\n\nCalculates the dot product of two vectors. Both vectors must have the same length. This function extends LinearAlgebra.dot. The multiplication and summation are performed using BigInt intermediates to avoid repeated HighPrecisionInt object creation during summation.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.@hpi_str-Tuple{String}","page":"API","title":"HighPrecisionArithmetic.@hpi_str","text":"@hpi_str(s::String)\n\nA string macro that creates a HighPrecisionInt from a string literal.\n\nExamples\n\njulia> hpi\"12345678901234567890\"\nHighPrecisionInt(12345678901234567890, coeffs=[124989312, 688091136, 166])\n\njulia> hpi\"-0xABCDEF\"\nHighPrecisionInt(-11259375, coeffs=[11259375])\n\n\n\n\n\n","category":"macro"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     HIGHPRECISIONBASE","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"This constant defines the base used for high-precision arithmetic, set to 2^32. ","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"It efficiently uses the UInt64 type to store 32-bit chunks, enabling safe intermediate operations ","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"like +, -, and * with carry, without risking overflow during computation.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Each element in the coeffs vector of a HighPrecisionInt represents a digit in this base, ","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"forming the foundation of our custom high-precision number representation. \"\"\" const HIGHPRECISIONBASE = UInt64(2)^32","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     HighPrecisionInt","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"A mutable struct representing a high-precision integer.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"It stores integer as an arbitrary length vector of coeffs::Vector{UInt64} coefficients in HIGH_PRECISION_BASE","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"and a sign::Int8 sign (1 for positive, -1 for negative, 0 for zero).","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"The coefficients are stored in little-endian order (least significant coefficient first).","category":"page"},{"location":"HighPrecisionInteger/#Inner-constructor","page":"High Precision Integer","title":"Inner constructor","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Constructs a HighPrecisionInt and normalizes to ensure a consistent representation based on HIGH_PRECISION_BASE. \"\"\" mutable struct HighPrecisionInt     coeffs::Vector{UInt64}  # Coefficients in little-endian order     sign::Int8              # 1 for positive, -1 for negative, 0 for zero","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"function HighPrecisionInt(coeffs::Vector{UInt64}, sign::Int8=Int8(1))\n    hpi = new(coeffs, sign)\n    normalize!(hpi) # Ensure consistent representation\n    return hpi\nend","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"HighPrecisionInt(x::HighPrecisionInt) = x","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     normalize!(hpi::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Normalizes a HighPrecisionInt in place, ensuring its internal representation is canonical and efficient.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"This function performs four crucial tasks:","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Initial Zero Check\nIf the coefficient vector is empty, the number is initialized to zero by adding a 0 coefficient and setting the sign to 0.\nFixes Carries/Borrows (Digit Overflow)\nFor coefficients c_i, ensure 0 le c_i  textHIGH_PRECISION_BASE by carrying over: c_i leftarrow c_i mod textHIGH_PRECISION_BASE\nRemoves Leading Zeros\nTrims unnecessary most significant zeros to keep the number compact.\nCorrects Signs\nSets sign to 0 if the number is zero; otherwise ensures it's positive if non-zero.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\" function normalize!(hpi::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"if isempty(hpi.coeffs)\n    hpi.sign = Int8(0)\n    push!(hpi.coeffs, UInt64(0))\n\n    return hpi\nend\n\ncarry = UInt64(0)\n\ni = 1\n# Iterate through coefficients, handling carries, and potentially extending the vector\n@inbounds while i <= length(hpi.coeffs) || carry > 0\n    current_coeff_val = (i <= length(hpi.coeffs) ? hpi.coeffs[i] : UInt64(0)) + carry\n\n    hpi.coeffs[i] = mod(current_coeff_val, HIGH_PRECISION_BASE)\n    carry = fld(current_coeff_val, HIGH_PRECISION_BASE)\n\n    # If we are at the end of the current coefficients and there's a carry,\n    # we need to push a new coefficient.\n    if i == length(hpi.coeffs) && carry > 0\n        push!(hpi.coeffs, UInt64(0))\n    end\n    i += 1\nend\n\n# Remove trailing (most significant) zero coefficients, but leave at least one if the number is zero.\nwhile length(hpi.coeffs) > 1 && hpi.coeffs[end] == 0\n    pop!(hpi.coeffs)\nend\n\n# Set sign to 0 if the number is actually zero\nif length(hpi.coeffs) == 1 && hpi.coeffs[1] == 0\n    hpi.sign = Int8(0)\n# If the sign was explicitly set to 0 but the value is non-zero, correct it to 1(positive).\nelseif hpi.sign == 0\n    hpi.sign = Int8(1)\nend\n\nreturn hpi","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     HighPrecisionInt(x::T) where {T<:Union{Integer, BigInt}}","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Creates a HighPrecisionInt from an Integer or BigInt x, representing it in base-HIGH_PRECISION_BASE.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Here's the breakdown:","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Handle Zero: \nIf x is zero, it returns a HighPrecisionInt representing zero directly.\nDetermine Sign: \nIt determines the sign of x (positive, negative).\nExtract Coefficients:  \nFor x compute coefficients c_i where 0 le c_i  textHIGH_PRECISION_BASE such that:\nsum_i=1^n c_i cdot textHIGH_PRECISION_BASE^i-1 = x\nusing repeated division and remainder: c_i = x mod textHIGH_PRECISION_BASE.\nThis yields the coefficients of the number x in base-HIGH_PRECISION_BASE in little-endian order.\nConstruct and Return: \nFinally, it constructs a HighPrecisionInt using the coefficients and the sign ordered from least to most significant.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\" function HighPrecisionInt(x::T) where {T<:Union{Integer,BigInt}}     if x == 0         return HighPrecisionInt([UInt64(0)], Int8(0)) # Special case for zero     end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"input_sign = Int8(x < 0 ? -1 : 1)\n\ncoeffs = UInt64[] \ntemp_abs_x = abs(x) \n\n# Repeatedly take quotient and remainders to get coefficients\nwhile temp_abs_x != 0\n    temp_abs_x, rem_val = divrem(temp_abs_x, HIGH_PRECISION_BASE)\n    push!(coeffs, UInt64(rem_val))\nend\nreturn HighPrecisionInt(coeffs, input_sign) # Construct and normalize","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     Base.BigInt(hpi::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Converts a HighPrecisionInt into a BigInt.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"It reconstructs the Big-Integer from its base-HIGH_PRECISION_BASE representation using the formula:","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"textBigInt = textsign times sum_i=1^n textcoeff_i times textHIGH_PRECISION_BASE^i-1","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"where textcoeff_i are the coefficients of the HighPrecisionInt and n is the number of coefficients. \"\"\" function Base.BigInt(hpi::HighPrecisionInt)     if hpi.sign == 0         return BigInt(0)     end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"result = sum(BigInt(coeff) * BigInt(HIGH_PRECISION_BASE)^(i-1) for (i, coeff) in enumerate(hpi.coeffs))\nreturn hpi.sign * result","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     Base.abs(hpi::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Returns the absolute value of a HighPrecisionInt. \"\"\" Base.abs(hpi::HighPrecisionInt) = HighPrecisionInt(copy(hpi.coeffs), abs(hpi.sign))","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     Base.isequal(a::HighPrecisionInt, b::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Checks whether two HighPrecisionInt numbers are equal (a == b). \"\"\" function Base.isequal(a::HighPrecisionInt, b::HighPrecisionInt)     a.sign != b.sign && return false     a.sign == 0 && b.sign == 0 && return true     length(a.coeffs) != length(b.coeffs) && return false     return a.coeffs == b.coeffs end Base.:(==)(a::HighPrecisionInt, b::HighPrecisionInt) = Base.isequal(a, b)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     Base.isless(a::HighPrecisionInt, b::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Compares two HighPrecisionInt numbers for less than (a < b).","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Here's the breakdown:","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Sign Comparison:\nIf textsign(a) neq textsign(b), then a  b Leftrightarrow textsign(a)  textsign(b).\nIf textsign(a) = textsign(b) = 0, they are equal, so a not b.\nMagnitude Comparison:  Let L_a L_b be the number of coefficients and c_a^k c_b^k be the k-th coefficients (most significant first).\nIf L_a neq L_b:\nFor positive numbers: a  b Leftrightarrow L_a  L_b.\nFor negative numbers: a  b Leftrightarrow L_a  L_b.\nIf L_a = L_b: Compare c_a^k and c_b^k from most significant (k=L_a) downwards.\nFor positive numbers: a  b if the first differing c_a^k  c_b^k.\nFor negative numbers: a  b if the first differing c_a^k  c_b^k.\nIf all coefficients are identical, a=b, so a not b.\nThe code uses a flip flag and XOR (⊻) to implement this logic concisely.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\" function Base.isless(a::HighPrecisionInt, b::HighPrecisionInt)     if a.sign != b.sign         return a.sign < b.sign     elseif a.sign == 0         return false     end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"flip = a.sign == -1\n\nla, lb = length(a.coeffs), length(b.coeffs)\nif la != lb\n    return flip ⊻ (la < lb)\nend\n\n@inbounds begin\n    for i in la:-1:1\n        c1, c2 = a.coeffs[i], b.coeffs[i]\n        if c1 != c2\n            return flip ⊻ (c1 < c2)\n        end\n    end\nend\n\nreturn false","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"end Base.:(<)(a::HighPrecisionInt, b::HighPrecisionInt) = Base.isless(a, b)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     abssubtract(acoeffs::Vector{UInt64}, b_coeffs::Vector{UInt64})","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Subtracts the magnitudes of two numbers represented by a_coeffs and b_coeffs (in base B=2^32), effectively computing a - b. Used when adding numbers of different signs in + operator. ","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Returns a tuple: (result_coeffs, is_negative_diff). result_coeffs is the vector of coefficients representing  a - b . is_negative_diff is true if b  a (i.e., the original difference a - b would be negative). This helper function is primarily used within the main addition/subtraction (+ or - operator overloads for HighPrecisionInt) when the operands have differing signs.","category":"page"},{"location":"HighPrecisionInteger/#Mathematical-Foundation","page":"High Precision Integer","title":"Mathematical Foundation","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Given non-negative numbers X Y represented by coefficient vectors a_coeffs and b_coeffs respectively in base B=2^32:","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"X = sum_k=1^textlength(a_coeffs) texta_coeffsk cdot B^k-1","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Y = sum_l=1^textlength(b_coeffs) textb_coeffsl cdot B^l-1","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"This function computes X - Y by subtracting the smaller magnitude from the larger. If X_k  Y_k + textborrow, a borrow of 1 from the next higher coefficient (effectively adding B to X_k) is performed. The is_negative_diff flag indicates if Y  X.","category":"page"},{"location":"HighPrecisionInteger/#Algorithm-Steps","page":"High Precision Integer","title":"Algorithm Steps","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Determine Larger Magnitude:       Compare a_coeffs and b_coeffsby length; if equal, compare the most significant differing digit. Setsamagis_larger`.\nAssign Operands: \nop1_coeffs holds the larger magnitude's coefficients, op2_coeffs the smaller.\nresult_coeffs is sized to match op1_coeffs.\nSubtract with Borrow:\nInitialize borrow = 0. For i = 1 dots textlength(op1_coeffs):\nLet v_1 = textop1_coeffsi and v_2 = (i le textlength(op2_coeffs)  textop2_coeffsi  0).\nIf v_1  v_2 + textborrow:   textresult_coeffsi leftarrow B + v_1 - v_2 - textborrow; textborrow leftarrow 1.\nElse:   textresult_coeffsi leftarrow v_1 - v_2 - textborrow; textborrow leftarrow 0.\nFinalize: \nTrim leading zeros from result_coeffs using resize!. \nIf result is zero, is_negative_diff becomes false.\nReturn (result_coeffs, !a_mag_is_larger).","category":"page"},{"location":"HighPrecisionInteger/#Implementation-Notes","page":"High Precision Integer","title":"Implementation Notes","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"- All coefficient values and intermediate arithmetic (sums, borrows)\n     are handled using `UInt64` to prevent overflow, as coefficients are less than ``2^{32}``.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\" function abssubtract(acoeffs::Vector{UInt64}, bcoeffs::Vector{UInt64})     lena, lenb = length(acoeffs), length(b_coeffs)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"# Determine larger magnitude \na_mag_is_larger = true\nif len_a < len_b\n    a_mag_is_larger = false\nelseif len_a == len_b\n    @inbounds for i in len_a:-1:1\n        if a_coeffs[i] < b_coeffs[i]\n            a_mag_is_larger = false\n            break\n        elseif a_coeffs[i] > b_coeffs[i]\n            a_mag_is_larger = true\n            break\n        end\n    end\nend\n\n# Prepare operands to ensure op1 >= op2 for subtraction\nop1_coeffs = a_mag_is_larger ? a_coeffs : b_coeffs\nop2_coeffs = a_mag_is_larger ? b_coeffs : a_coeffs\n\nlen_op1 = length(op1_coeffs)\nlen_op2 = length(op2_coeffs)\nresult_coeffs = Vector{UInt64}(undef, len_op1)\nborrow = UInt64(0)\n\n# Subtract common length portion\nmin_coeffs_len = min(len_op1, len_op2)\n@inbounds for i in 1:min_coeffs_len\n    if op1_coeffs[i] < op2_coeffs[i] + borrow\n        result_coeffs[i] = HIGH_PRECISION_BASE + op1_coeffs[i] - op2_coeffs[i] - borrow\n        borrow = UInt64(1)\n    else\n        result_coeffs[i] = op1_coeffs[i] - op2_coeffs[i] - borrow\n        borrow = UInt64(0)\n    end\nend\n\n# Propagate borrow through remaining digits of larger number\n@inbounds for i in (min_coeffs_len + 1):len_op1\n    if op1_coeffs[i] < borrow\n        result_coeffs[i] = HIGH_PRECISION_BASE + op1_coeffs[i] - borrow\n        borrow = UInt64(1)\n    else\n        result_coeffs[i] = op1_coeffs[i] - borrow\n        borrow = UInt64(0)\n    end\nend\n\n# Trim leading zeros\nlast_idx = len_op1\nwhile last_idx > 1 && result_coeffs[last_idx] == 0\n    last_idx -= 1\nend\nresize!(result_coeffs, last_idx)\n\n# Handle zero result\nif length(result_coeffs) == 1 && result_coeffs[1] == 0\n    return (result_coeffs, false)\nend\n\n# Return result and sign indicator\nreturn (result_coeffs, !a_mag_is_larger)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     Base.:-(hpi::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Unary negation operator for HighPrecisionInt. \"\"\" function Base.:-(hpi::HighPrecisionInt)     if hpi.sign == 0         return HighPrecisionInt([UInt64(0)], Int8(0)) # Negating zero is zero     else         return HighPrecisionInt(copy(hpi.coeffs), -hpi.sign) # Flip the sign     end end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\" Base.:+(a::HighPrecisionInt, b::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Adds two HighPrecisionInt numbers, a and b.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Performs efficient large-integer addition using sign handling and base-2^32 arithmetic with carry propagation.","category":"page"},{"location":"HighPrecisionInteger/#Mathematical-Foundation-2","page":"High Precision Integer","title":"Mathematical Foundation","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Let a = textsign_a cdot a and b = textsign_b cdot b, where coefficients are in base B=2^32.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Same Signs (textsign_a = textsign_b):    The result is textsign_a cdot (a + b) using standard digit-wise addition with carry propagation.\nDifferent Signs (textsign_a neq textsign_b):    The result simplifies to a subtraction of absolute values,        i.e., a + b = pm (a - b), where the pm with sign from the larger operand.       This is handled by an abs_subtract function.","category":"page"},{"location":"HighPrecisionInteger/#Algorithm","page":"High Precision Integer","title":"Algorithm","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Zero Check: If either a or b is zero, the other operand is returned.\nSame Sign Addition:\nInitialize a result_coeffs vector and carry = 0.\nIterate, summing corresponding coefficients of a b   from left to right (padding with UInt64(0) if needed) and the current carry.\nThe current result digit is (sum) & MASK32 (lower 32 bits),    and the new carry is (sum) >> 32 (upper 32 bits).\nAppend any final carry to result_coeffs.\nThe result inherits the common sign of a and b.\nDifferent Sign Subtraction:\nIf signs differ (e.g., a  0 b  0), abs_subtract(a.coeffs, b.coeffs) (or b.coeffs, a.coeffs if a  0 b  0) is invoked.\nIf the result of abs_subtract indicates a negative difference,   the final sign is negative; otherwise, it's positive.","category":"page"},{"location":"HighPrecisionInteger/#Implementation-Notes-2","page":"High Precision Integer","title":"Implementation Notes","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"All arithmetic uses UInt64 with bitwise ops (& MASK32, >> 32) to extract coefficients and carries efficiently. \n@inbounds is used in loops for performance, assuming safe indexing.  \nabs_subtract handles differing signs by computing the absolute difference and its sign.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\" function Base.:+(a::HighPrecisionInt, b::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"# Handle addition with zero\nif a.sign == 0\n    return b\nend\nif b.sign == 0\n    return a\nend\n\nMASK32 = 0xffffffff # Mask for lower 32 bits\n\n# Case 1: Both numbers have the same sign (add magnitudes)\nif a.sign == b.sign\n    max_len = max(length(a.coeffs), length(b.coeffs))\n    result_coeffs = Vector{UInt64}(undef, max_len)\n    \n    carry = UInt64(0)\n\n    @inbounds for i in 1:max_len\n        val_a = i <= length(a.coeffs) ? a.coeffs[i] : UInt64(0)\n        val_b = i <= length(b.coeffs) ? b.coeffs[i] : UInt64(0)\n\n        current_sum = val_a + val_b + carry\n\n        result_coeffs[i] = current_sum & MASK32\n        carry = current_sum >> 32\n    end\n\n    # Handle any final carry\n    if carry > 0\n        push!(result_coeffs, carry)\n    end\n    \n    return HighPrecisionInt(result_coeffs, a.sign)\n\n# Case 2: Signs are different (subtract magnitudes)\nelseif a.sign == 1 && b.sign == -1 # a is positive, b is negative\n    result_coeffs_raw, is_negative_diff = abs_subtract(a.coeffs, b.coeffs)\n    final_sign = is_negative_diff ? Int8(-1) : Int8(1)\n    return HighPrecisionInt(result_coeffs_raw, final_sign)\n\nelse # a is negative, b is positive\n    result_coeffs_raw, is_negative_diff = abs_subtract(b.coeffs, a.coeffs) \n    final_sign = is_negative_diff ? Int8(-1) : Int8(1)\n    return HighPrecisionInt(result_coeffs_raw, final_sign)\nend","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     Base.:-(a::HighPrecisionInt, b::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Subtraction operator for HighPrecisionInt. \"\"\" Base.:-(a::HighPrecisionInt, b::HighPrecisionInt) = a + (-b)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     Base.:*(a::HighPrecisionInt, b::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Multiplies two HighPrecisionInt numbers, a and b.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"The method implements long multiplication using base B = 2^32 (HIGH_PRECISION_BASE).","category":"page"},{"location":"HighPrecisionInteger/#Mathematical-Foundation-3","page":"High Precision Integer","title":"Mathematical Foundation","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Let a = sum_k=1^textlen_a a_k cdot B^k-1 and b = sum_l=1^textlen_b b_l cdot B^l-1, where a_k = textacoeffsk and b_l = textbcoeffsl are coefficients in base B.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"The product is a cdot b = sum_k=1^textlen_a sum_l=1^textlen_b (a_k cdot b_l) cdot B^k+l-2.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Each partial product p_kl = a_k cdot b_l (a UInt64, prod in code) can be written as p_kl = lo_kl + hi_kl cdot B, where:","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"lo_kl = p_kl pmod B (lower 32 bits, prod & MASK32)\nhi_kl = lfloor p_kl  B rfloor (upper 32 bits, prod >> 32).","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"The term (a_k cdot b_l) cdot B^k+l-2 contributes lo_kl to the coefficient of B^k+l-2 (index k+l-1 in the result vector) and hi_kl to the coefficient of B^k+l-1 (index k+l in the result vector). These contributions are summed up with carries.","category":"page"},{"location":"HighPrecisionInteger/#Algorithm-Steps-2","page":"High Precision Integer","title":"Algorithm Steps","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Handle Zero: If atextsign = 0 or btextsign = 0, the result is HighPrecisionInt(0).\nInitialize Result: A zero-filled UInt64 vector result of length len_a + len_b is created,      where len_a and len_b are the lengths of a.coeffs and b.coeffs.\nMultiply and Accumulate with Carry:  For each a_i (a.coeffs[i]) and b_j (b.coeffs[j]):\na.  Compute partial product: p = a_i cdot b_j (a UInt64).\nb.  Split p into 32-bit parts: lo = p pmod B (i.e., p & MASK32), hi = p gg 32.\nc.  Accumulate lo:      At index k = i+j-1:      result[k] \\\\leftarrow result[k] + lo      carry = result[k] \\\\gg 32 (extract carry from the sum)      result[k] \\\\leftarrow result[k] \\\\pmod B (or result[k] \\\\&= \\\\text{MASK32})\nd.  Accumulate hi and carry:      At index k leftarrow k+1 (now i+j):      result[k] \\\\leftarrow result[k] + hi + \\\\text{carry}_{\\\\text{prev_step}}      carry = result[k] \\\\gg 32      result[k] \\\\leftarrow result[k] \\\\pmod B\ne.  Propagate Final Carry:      While carry \\\\neq 0:      k leftarrow k+1.      result[k] \\\\leftarrow result[k] + carry      carry_{\\\\text{new}} = result[k] \\\\gg 32      result[k] \\\\leftarrow result[k] \\\\pmod B      carry \\\\leftarrow carry_{\\\\text{new}}\nFinalize: Trim leading zeros from result, set sign as a.sign * b.sign,  and return the HighPrecisionInt.","category":"page"},{"location":"HighPrecisionInteger/#Implementation-Notes-3","page":"High Precision Integer","title":"Implementation Notes","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Coefficients a_i b_j  2^32, so their product a_i cdot b_j  2^64 (fits in UInt64).\nAll arithmetic for accumulation and carry uses UInt64    with bitwise operations (& MASK32, >> 32) for efficiency and to prevent overflow.\n@inbounds is used in loops for performance.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\" function Base.:*(a::HighPrecisionInt, b::HighPrecisionInt)     # If either operand is zero, the product is zero     if a.sign == 0 || b.sign == 0         return HighPrecisionInt([UInt64(0)], Int8(0))     end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"len_a, len_b = length(a.coeffs), length(b.coeffs)\nresult_len = len_a + len_b\nresult = Vector{UInt64}(undef, result_len)\nfill!(result, 0)\n\nMASK32 = 0xffffffff\nBASE32 = 0x1_0000_0000\n\n@inbounds for i in 1:len_a\n    ai = a.coeffs[i]\n    for j in 1:len_b\n        prod = ai * b.coeffs[j]\n        lo = prod & MASK32\n        hi = prod >> 32\n\n        k = i + j - 1\n        result[k] += lo\n        carry = result[k] >> 32\n        result[k] &= MASK32\n\n        k += 1\n        result[k] += hi + carry\n        carry = result[k] >> 32\n        result[k] &= MASK32\n\n        while carry != 0\n            k += 1\n            result[k] += carry\n            carry = result[k] >> 32\n            result[k] &= MASK32\n        end\n    end\nend\n\n# Trim leading zeros\nwhile length(result) > 1 && result[end] == 0\n    pop!(result)\nend\n\nreturn HighPrecisionInt(result, a.sign * b.sign)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     Base.show(io::IO, hpi::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Defines how a HighPrecisionInt is displayed by converting it  to a BigInt for a user-friendly decimal representation and its internal coefficient representation. \"\"\" function Base.show(io::IO, hpi::HighPrecisionInt)     if hpi.sign == 0         print(io, \"HighPrecisionInt(0, coeffs=[])\")     else         # Convert to BigInt for display, ensuring the sign is correct         value = hpi.sign * BigInt(abs(hpi))","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"    coeffs_str = \"[\" * join(hpi.coeffs .|> Int, \", \") * \"]\"\n    print(io, \"HighPrecisionInt($value, coeffs=$coeffs_str)\")\nend","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"end","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\"     @hpi_str(s::String)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"A string macro that creates a HighPrecisionInt from a string literal.","category":"page"},{"location":"HighPrecisionInteger/#Examples","page":"High Precision Integer","title":"Examples","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> hpi\"12345678901234567890\"\nHighPrecisionInt(12345678901234567890, coeffs=[124989312, 688091136, 166])\n\njulia> hpi\"-0xABCDEF\"\nHighPrecisionInt(-11259375, coeffs=[11259375])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"\"\"\" macro hpi_str(s::String)     try         return :(HighPrecisionInt((parse(BigInt s))))     catch e         return (error(Invalid hpi input  * (Metaquot(s))) *  Original error  * string(e))     end end","category":"page"},{"location":"HighPrecisionLinearAlgebra/#High-Precision-Linear-Algebra","page":"High Precision Linear Algebra","title":"🧮 High Precision Linear Algebra","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"This module extends the functionality of HighPrecisionNumber by providing basic linear algebra operations for vectors and matrices using HighPrecisionInt elements. It enables computations with arbitrary-precision numbers in vector and matrix contexts.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Dependencies","page":"High Precision Linear Algebra","title":"📦 Dependencies","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"HighPrecisionNumber: Provides the HighPrecisionInt type.\nLinearAlgebra (Base): Required for defining and overloading operations like dot.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Type-Definitions","page":"High Precision Linear Algebra","title":"🔧 Type Definitions","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/#HighPrecisionVector","page":"High Precision Linear Algebra","title":"📐 HighPrecisionVector","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"Represents a high-precision vector.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"mutable struct HighPrecisionVector\n    elements::Vector{HighPrecisionInt}\nend","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Constructors:","page":"High Precision Linear Algebra","title":"🛠️ Constructors:","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"HighPrecisionVector(elements::Vector{HighPrecisionInt})   From high-precision elements.\nHighPrecisionVector(elements::Vector{T}) where {T<:Union{Integer, BigInt}}   Automatically converts standard integers to HighPrecisionInt.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#HighPrecisionMatrix","page":"High Precision Linear Algebra","title":"🧱 HighPrecisionMatrix","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"Represents a high-precision matrix.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"mutable struct HighPrecisionMatrix\n    elements::Vector{Vector{HighPrecisionInt}}\n    rows::Int\n    cols::Int\nend","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Constructors:-2","page":"High Precision Linear Algebra","title":"🛠️ Constructors:","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"HighPrecisionMatrix(elements::Vector{Vector{HighPrecisionInt}})   Validates consistent column lengths.\nHighPrecisionMatrix(elements::Vector{Vector{T}}) where {T<:Union{Integer, BigInt}}   Converts integers to HighPrecisionInt.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Operator-Overloads-and-Functions","page":"High Precision Linear Algebra","title":"➕ Operator Overloads and Functions","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/#Vector-Operations","page":"High Precision Linear Algebra","title":"📏 Vector Operations","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"Base.:+(v1::HighPrecisionVector, v2::HighPrecisionVector)\nBase.:-(v1::HighPrecisionVector, v2::HighPrecisionVector)\nBase.:*(scalar::Union{Integer, BigInt, HighPrecisionInt}, v::HighPrecisionVector)\nBase.:*(v::HighPrecisionVector, scalar::Union{Integer, BigInt, HighPrecisionInt})\nLinearAlgebra.dot(v1::HighPrecisionVector, v2::HighPrecisionVector)","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"ℹ️ dot uses BigInt internally for accumulation and returns a HighPrecisionInt.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Matrix-Operations","page":"High Precision Linear Algebra","title":"🧮 Matrix Operations","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"Base.:+(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)\nBase.:-(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)\nBase.:*(scalar, m::HighPrecisionMatrix)\nBase.:*(m::HighPrecisionMatrix, scalar)\nBase.:*(m::HighPrecisionMatrix, v::HighPrecisionVector)\nBase.:*(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"ℹ️ Internally uses BigInt for intermediate results to ensure precision.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Display-Methods","page":"High Precision Linear Algebra","title":"🖨️ Display Methods","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"Base.show(io::IO, v::HighPrecisionVector)\nBase.show(io::IO, m::HighPrecisionMatrix)","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Usage-Examples","page":"High Precision Linear Algebra","title":"🧪 Usage Examples","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"# 📥 Include required modules\ninclude(\"HighPrecisionNumber.jl\")\ninclude(\"HighPrecisionLinearAlgebra.jl\")\nusing .HighPrecisionLinearAlgebra\nusing .HighPrecisionNumber\n\nprintln(\"--- HighPrecisionLinearAlgebra Usage Examples ---\")\n\n# 1️⃣ HighPrecisionVector Creation\nvec1 = HighPrecisionVector([1, -2])\nvec2 = HighPrecisionVector([1000, -500, 200])\nlarge_vec = HighPrecisionVector([BigInt(2)^70, -BigInt(2)^75, BigInt(2)^80])\n\n# 2️⃣ Vector Addition & Subtraction\nvec1_compat = HighPrecisionVector([1, 2, 3])\nvec2_compat = HighPrecisionVector([10, 20, 30])\nv_sum = vec1_compat + vec2_compat\nv_diff = vec1_compat - vec2_compat\n\n# 3️⃣ Scalar Multiplication\nscalar_val = HighPrecisionInt(5)\nv_scaled = scalar_val * HighPrecisionVector([1, -2, 3])\n\n# 4️⃣ Dot Product\ndot_vec_a = HighPrecisionVector([1, 2, 3])\ndot_vec_b = HighPrecisionVector([4, 5, 6])\nv_dot = LinearAlgebra.dot(dot_vec_a, dot_vec_b)\n\n# 5️⃣ Matrix Creation\nmat1 = HighPrecisionMatrix([[1, 2], [3, 4]])\nmat2 = HighPrecisionMatrix([[5, 6], [7, 8]])\nlarge_mat = HighPrecisionMatrix([\n    [BigInt(2)^60, -BigInt(2)^62],\n    [BigInt(2)^65, BigInt(2)^67]\n])\n\n# 6️⃣ Matrix Addition & Subtraction\nm_sum = mat1 + mat2\nm_diff = mat1 - mat2\n\n# 7️⃣ Matrix Scalar Multiplication\nm_scaled = HighPrecisionInt(3) * mat1\n\n# 8️⃣ Matrix-Vector Multiplication\nm_vec_prod = mat1 * vec1\n\n# 9️⃣ Matrix-Matrix Multiplication\nm_mat_prod = mat1 * mat2\n\n# 🖨️ Display Results\nprintln(\"vec1 = $vec1\")\nprintln(\"vec2 = $vec2\")\nprintln(\"large_vec = $large_vec\")\nprintln(\"v_sum = $v_sum\")\nprintln(\"v_diff = $v_diff\")\nprintln(\"v_scaled = $v_scaled\")\nprintln(\"v_dot = $v_dot\")\nprintln(\"mat1 = \\n$mat1\")\nprintln(\"mat2 = \\n$mat2\")\nprintln(\"large_mat = \\n$large_mat\")\nprintln(\"m_sum = \\n$m_sum\")\nprintln(\"m_diff = \\n$m_diff\")\nprintln(\"m_scaled = \\n$m_scaled\")\nprintln(\"m_vec_prod = $m_vec_prod\")\nprintln(\"m_mat_prod = \\n$m_mat_prod\")\n\nprintln(\"\\n--- ✅ End of Examples ---\")","category":"page"},{"location":"#High-Precision-Arithmetic-Library","page":"Home","title":"High Precision Arithmetic Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for the High Precision Arithmetic Library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This library provides arbitrary-precision arithmetic and linear algebra operations built on top of it.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High Precision Integer\nHigh Precision Linear Algebra","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High Precision Arithmetic API","category":"page"}]
}
