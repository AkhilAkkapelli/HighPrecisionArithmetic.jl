var documenterSearchIndex = {"docs":
[{"location":"api/high-precision-arithmetic/#High-Precision-Arithmetic-API","page":"API","title":"High Precision Arithmetic API","text":"","category":"section"},{"location":"api/high-precision-arithmetic/","page":"API","title":"API","text":"This section details the HighPrecisionArithmetic module.","category":"page"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.HIGH_PRECISION_BASE","page":"API","title":"HighPrecisionArithmetic.HIGH_PRECISION_BASE","text":"HIGH_PRECISION_BASE\n\nThis constant defines the base used for high-precision arithmetic, set to 2^32. \n\nIt efficiently uses the UInt64 type to store 32-bit chunks, enabling safe intermediate operations \n\nlike +, -, and * with carry, without risking overflow during computation.\n\nEach element in the coeffs vector of a HighPrecisionInt represents a digit in this base, \n\nforming the foundation of our custom high-precision number representation.\n\n\n\n\n\n","category":"constant"},{"location":"api/high-precision-arithmetic/#Base.GMP.BigInt-Tuple{HighPrecisionInt}","page":"API","title":"Base.GMP.BigInt","text":"Base.BigInt(hpi::HighPrecisionInt)\n\nConverts a HighPrecisionInt into a BigInt.\n\nIt reconstructs the Big-Integer from its base-HIGH_PRECISION_BASE representation using the formula:\n\ntextBigInt = textsign times sum_i=1^n textcoeff_i times textHIGH_PRECISION_BASE^i-1\n\nwhere textcoeff_i are the coefficients of the HighPrecisionInt and n is the number of coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.HighPrecisionInt","page":"API","title":"HighPrecisionArithmetic.HighPrecisionInt","text":"HighPrecisionInt\n\nA mutable struct representing a high-precision integer.\n\nIt stores integer as an arbitrary length vector of coeffs::Vector{UInt64} coefficients in HIGH_PRECISION_BASE\n\nand a sign::Int8 sign (1 for positive, -1 for negative, 0 for zero).\n\nThe coefficients are stored in little-endian order (least significant coefficient first).\n\nInner constructor\n\nConstructs a HighPrecisionInt and normalizes to ensure a consistent representation based on HIGH_PRECISION_BASE.\n\n\n\n\n\n","category":"type"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.HighPrecisionInt-Tuple{T} where T<:Integer","page":"API","title":"HighPrecisionArithmetic.HighPrecisionInt","text":"HighPrecisionInt(x::T) where {T<:Union{Integer, BigInt}}\n\nCreates a HighPrecisionInt from an Integer or BigInt x, representing it in base-HIGH_PRECISION_BASE.\n\nHere's the breakdown:\n\nHandle Zero: \nIf x is zero, it returns a HighPrecisionInt representing zero directly.\nDetermine Sign: \nIt determines the sign of x (positive, negative).\nExtract Coefficients:  \nFor x compute coefficients c_i where 0 le c_i  textHIGH_PRECISION_BASE such that:   math   \\sum_{i=1}^{n} c_i \\cdot \\text{HIGH\\_PRECISION\\_BASE}^{i-1} = |x|   using repeated division and remainder: c_i = x mod textHIGH_PRECISION_BASE.\nThis yields the coefficients of the number x in base-HIGH_PRECISION_BASE in little-endian order.\nConstruct and Return: \nFinally, it constructs a HighPrecisionInt using the coefficients and the sign ordered from least to most significant.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.HighPrecisionMatrix","page":"API","title":"HighPrecisionArithmetic.HighPrecisionMatrix","text":"HighPrecisionMatrix\n\nA mutable struct representing a high-precision matrix. It stores a 2D array (Vector of Vectors) of HighPrecisionInt elements.\n\n\n\n\n\n","category":"type"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.HighPrecisionVector","page":"API","title":"HighPrecisionArithmetic.HighPrecisionVector","text":"HighPrecisionVector\n\nA mutable struct representing a high-precision vector. It stores a vector of HighPrecisionInt elements.\n\n\n\n\n\n","category":"type"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{HighPrecisionInt, HighPrecisionInt}","page":"API","title":"Base.:*","text":"Base.:*(a::HighPrecisionInt, b::HighPrecisionInt)\n\nMultiplies two HighPrecisionInt numbers, a and b.\n\nThe method implements long multiplication using base B = 2^32 (HIGH_PRECISION_BASE).\n\nMathematical Foundation\n\nLet a = sum_k=1^textlen_a a_k cdot B^k-1 and b = sum_l=1^textlen_b b_l cdot B^l-1, where a_k = textacoeffsk and b_l = textbcoeffsl are coefficients in base B.\n\nThe product is a cdot b = sum_k=1^textlen_a sum_l=1^textlen_b (a_k cdot b_l) cdot B^k+l-2.\n\nEach partial product p_kl = a_k cdot b_l (a UInt64, prod in code) can be written as p_kl = lo_kl + hi_kl cdot B, where:\n\nlo_kl = p_kl pmod B (lower 32 bits, prod & MASK32)\nhi_kl = lfloor p_kl  B rfloor (upper 32 bits, prod >> 32).\n\nThe term (a_k cdot b_l) cdot B^k+l-2 contributes lo_kl to the coefficient of B^k+l-2 (index k+l-1 in the result vector) and hi_kl to the coefficient of B^k+l-1 (index k+l in the result vector). These contributions are summed up with carries.\n\nAlgorithm Steps\n\nHandle Zero: If atextsign = 0 or btextsign = 0, the result is HighPrecisionInt(0).\nInitialize Result: A zero-filled UInt64 vector result of length len_a + len_b is created,      where len_a and len_b are the lengths of a.coeffs and b.coeffs.\nMultiply and Accumulate with Carry:  For each a_i (a.coeffs[i]) and b_j (b.coeffs[j]):  a.  Compute partial product: p = a_i cdot b_j (a UInt64).  b.  Split p into 32-bit parts: lo = p pmod B (i.e., p & MASK32), hi = p gg 32.  c.  Accumulate lo:      At index k = i+j-1:      result[k] \\leftarrow result[k] + lo      carry = result[k] \\gg 32 (extract carry from the sum)      result[k] \\leftarrow result[k] \\pmod B (or result[k] \\&= \\text{MASK32})  d.  Accumulate hi and carry:      At index k leftarrow k+1 (now i+j):      result[k] \\leftarrow result[k] + hi + \\text{carry}_{\\text{prev_step}}      carry = result[k] \\gg 32      result[k] \\leftarrow result[k] \\pmod B  e.  Propagate Final Carry:      While carry \\neq 0:      k leftarrow k+1.      result[k] \\leftarrow result[k] + carry      carry_{\\text{new}} = result[k] \\gg 32      result[k] \\leftarrow result[k] \\pmod B      carry \\leftarrow carry_{\\text{new}}\nFinalize: Trim leading zeros from result, set sign as a.sign * b.sign,      and return the HighPrecisionInt.\n\nImplementation Notes\n\nCoefficients a_i b_j  2^32, so their product a_i cdot b_j  2^64 (fits in UInt64).\nAll arithmetic for accumulation and carry uses UInt64    with bitwise operations (& MASK32, >> 32) for efficiency and to prevent overflow.\n@inbounds is used in loops for performance.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{HighPrecisionMatrix, HighPrecisionMatrix}","page":"API","title":"Base.:*","text":"Base.:*(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)\n\nMatrix-matrix multiplication. Number of columns in m1 must equal number of rows in m2. The multiplication and summation are performed using BigInt intermediates to avoid repeated HighPrecisionInt object creation during summation for each element.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{HighPrecisionMatrix, HighPrecisionVector}","page":"API","title":"Base.:*","text":"Base.:*(m::HighPrecisionMatrix, v::HighPrecisionVector)\n\nMatrix-vector multiplication. Number of matrix columns must equal vector length. The multiplication and summation are performed using BigInt intermediates to avoid repeated HighPrecisionInt object creation during summation for each element.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{HighPrecisionMatrix, Union{Integer, HighPrecisionInt}}","page":"API","title":"Base.:*","text":"Base.:*(m::HighPrecisionMatrix, scalar::Union{Integer, BigInt, HighPrecisionInt})\n\nScalar-matrix multiplication (matrix * scalar).\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{HighPrecisionVector, Union{Integer, HighPrecisionInt}}","page":"API","title":"Base.:*","text":"Base.:*(v::HighPrecisionVector, scalar::Union{Integer, BigInt, HighPrecisionInt})\n\nScalar-vector multiplication (vector * scalar).\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{Union{Integer, HighPrecisionInt}, HighPrecisionMatrix}","page":"API","title":"Base.:*","text":"Base.:*(scalar::Union{Integer, BigInt, HighPrecisionInt}, m::HighPrecisionMatrix)\n\nScalar-matrix multiplication (scalar * matrix).\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:*-Tuple{Union{Integer, HighPrecisionInt}, HighPrecisionVector}","page":"API","title":"Base.:*","text":"Base.:*(scalar::Union{Integer, BigInt, HighPrecisionInt}, v::HighPrecisionVector)\n\nScalar-vector multiplication (scalar * vector).\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:+-Tuple{HighPrecisionInt, HighPrecisionInt}","page":"API","title":"Base.:+","text":"Base.:+(a::HighPrecisionInt, b::HighPrecisionInt)\n\nAdds two HighPrecisionInt numbers, a and b.\n\nPerforms efficient large-integer addition using sign handling and base-2^32 arithmetic with carry propagation.\n\nMathematical Foundation\n\nLet a = textsign_a cdot a and b = textsign_b cdot b, where coefficients are in base B=2^32.\n\nSame Signs (textsign_a = textsign_b):    The result is textsign_a cdot (a + b) using standard digit-wise addition with carry propagation.\nDifferent Signs (textsign_a neq textsign_b):    The result simplifies to a subtraction of absolute values,        i.e., a + b = pm (a - b), where the pm with sign from the larger operand.       This is handled by an abs_subtract function.\n\n\n\nAlgorithm\n\nZero Check: If either a or b is zero, the other operand is returned.\nSame Sign Addition:\nInitialize a result_coeffs vector and carry = 0.\nIterate, summing corresponding coefficients of a b   from left to right (padding with UInt64(0) if needed) and the current carry.\nThe current result digit is (sum) & MASK32 (lower 32 bits),    and the new carry is (sum) >> 32 (upper 32 bits).\nAppend any final carry to result_coeffs.\nThe result inherits the common sign of a and b.\nDifferent Sign Subtraction:\nIf signs differ (e.g., a  0 b  0), abs_subtract(a.coeffs, b.coeffs) (or b.coeffs, a.coeffs if a  0 b  0) is invoked.\nIf the result of abs_subtract indicates a negative difference,   the final sign is negative; otherwise, it's positive.\n\n\n\nImplementation Notes\n\nAll arithmetic uses UInt64 with bitwise ops (& MASK32, >> 32) to extract coefficients and carries efficiently. \n@inbounds is used in loops for performance, assuming safe indexing.  \nabs_subtract handles differing signs by computing the absolute difference and its sign.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:+-Tuple{HighPrecisionMatrix, HighPrecisionMatrix}","page":"API","title":"Base.:+","text":"Base.:+(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)\n\nMatrix addition. Both matrices must have the same dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:+-Tuple{HighPrecisionVector, HighPrecisionVector}","page":"API","title":"Base.:+","text":"Base.:+(v1::HighPrecisionVector, v2::HighPrecisionVector)\n\nVector addition. Both vectors must have the same length.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:--Tuple{HighPrecisionInt, HighPrecisionInt}","page":"API","title":"Base.:-","text":"Base.:-(a::HighPrecisionInt, b::HighPrecisionInt)\n\nSubtraction operator for HighPrecisionInt.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:--Tuple{HighPrecisionInt}","page":"API","title":"Base.:-","text":"Base.:-(hpi::HighPrecisionInt)\n\nUnary negation operator for HighPrecisionInt.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:--Tuple{HighPrecisionMatrix, HighPrecisionMatrix}","page":"API","title":"Base.:-","text":"Base.:-(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)\n\nMatrix subtraction. Both matrices must have the same dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.:--Tuple{HighPrecisionVector, HighPrecisionVector}","page":"API","title":"Base.:-","text":"Base.:-(v1::HighPrecisionVector, v2::HighPrecisionVector)\n\nVector subtraction. Both vectors must have the same length.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.abs-Tuple{HighPrecisionInt}","page":"API","title":"Base.abs","text":"Base.abs(hpi::HighPrecisionInt)\n\nReturns the absolute value of a HighPrecisionInt.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.isequal-Tuple{HighPrecisionInt, HighPrecisionInt}","page":"API","title":"Base.isequal","text":"Base.isequal(a::HighPrecisionInt, b::HighPrecisionInt)\n\nChecks whether two HighPrecisionInt numbers are equal (a == b).\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.isless-Tuple{HighPrecisionInt, HighPrecisionInt}","page":"API","title":"Base.isless","text":"Base.isless(a::HighPrecisionInt, b::HighPrecisionInt)\n\nCompares two HighPrecisionInt numbers for less than (a < b).\n\nHere's the breakdown:\n\nSign Comparison:\nIf textsign(a) neq textsign(b), then a  b Leftrightarrow textsign(a)  textsign(b).\nIf textsign(a) = textsign(b) = 0, they are equal, so a not b.\nMagnitude Comparison:  Let L_a L_b be the number of coefficients and c_a^k c_b^k be the k-th coefficients (most significant first).\nIf L_a neq L_b:\nFor positive numbers: a  b Leftrightarrow L_a  L_b.\nFor negative numbers: a  b Leftrightarrow L_a  L_b.\nIf L_a = L_b: Compare c_a^k and c_b^k from most significant (k=L_a) downwards.\nFor positive numbers: a  b if the first differing c_a^k  c_b^k.\nFor negative numbers: a  b if the first differing c_a^k  c_b^k.\nIf all coefficients are identical, a=b, so a not b.\nThe code uses a flip flag and XOR (⊻) to implement this logic concisely.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#Base.show-Tuple{IO, HighPrecisionInt}","page":"API","title":"Base.show","text":"Base.show(io::IO, hpi::HighPrecisionInt)\n\nDefines how a HighPrecisionInt is displayed by converting it  to a BigInt for a user-friendly decimal representation and its internal coefficient representation.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.abs_subtract-Tuple{Vector{UInt64}, Vector{UInt64}}","page":"API","title":"HighPrecisionArithmetic.abs_subtract","text":"abs_subtract(a_coeffs::Vector{UInt64}, b_coeffs::Vector{UInt64})\n\nSubtracts the magnitudes of two numbers represented by a_coeffs and b_coeffs (in base B=2^32), effectively computing a - b. Used when adding numbers of different signs in + operator. \n\nReturns a tuple: (result_coeffs, is_negative_diff). result_coeffs is the vector of coefficients representing  a - b . is_negative_diff is true if b  a (i.e., the original difference a - b would be negative). This helper function is primarily used within the main addition/subtraction (+ or - operator overloads for HighPrecisionInt) when the operands have differing signs. –-\n\nMathematical Foundation\n\nGiven non-negative numbers X Y represented by coefficient vectors a_coeffs and b_coeffs respectively in base B=2^32:\n\nX = sum_k=1^textlength(a_coeffs) texta_coeffsk cdot B^k-1\n\nY = sum_l=1^textlength(b_coeffs) textb_coeffsl cdot B^l-1\n\n\nThis function computes X - Y by subtracting the smaller magnitude from the larger. If X_k  Y_k + textborrow, a borrow of 1 from the next higher coefficient (effectively adding B to X_k) is performed. The is_negative_diff flag indicates if Y  X. –-\n\nAlgorithm Steps\n\nDetermine Larger Magnitude:       Compare a_coeffs and b_coeffsby length; if equal, compare the most significant differing digit. Setsamagis_larger`.\nAssign Operands: \nop1_coeffs holds the larger magnitude's coefficients, op2_coeffs the smaller.\nresult_coeffs is sized to match op1_coeffs.\nSubtract with Borrow:\nInitialize borrow = 0. For i = 1 dots textlength(op1_coeffs):\nLet v_1 = textop1_coeffsi and v_2 = (i le textlength(op2_coeffs)  textop2_coeffsi  0).\nIf v_1  v_2 + textborrow:   textresult_coeffsi leftarrow B + v_1 - v_2 - textborrow; textborrow leftarrow 1.\nElse:   textresult_coeffsi leftarrow v_1 - v_2 - textborrow; textborrow leftarrow 0.\nFinalize: \nTrim leading zeros from result_coeffs using resize!. \nIf result is zero, is_negative_diff becomes false.\nReturn (result_coeffs, !a_mag_is_larger).\n\nImplementation Notes\n\n- All coefficient values and intermediate arithmetic (sums, borrows)\n     are handled using `UInt64` to prevent overflow, as coefficients are less than ``2^{32}``.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.normalize!-Tuple{HighPrecisionInt}","page":"API","title":"HighPrecisionArithmetic.normalize!","text":"normalize!(hpi::HighPrecisionInt)\n\nNormalizes a HighPrecisionInt in place, ensuring its internal representation is canonical and efficient.\n\nThis function performs four crucial tasks:\n\nInitial Zero Check\nIf the coefficient vector is empty, the number is initialized to zero by adding a 0 coefficient and setting the sign to 0.\nFixes Carries/Borrows (Digit Overflow)\nFor coefficients c_i, ensure 0 le c_i  textHIGH_PRECISION_BASE by carrying over: c_i leftarrow c_i mod textHIGH_PRECISION_BASE\nRemoves Leading Zeros\nTrims unnecessary most significant zeros to keep the number compact.\nCorrects Signs\nSets sign to 0 if the number is zero; otherwise ensures it's positive if non-zero.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#LinearAlgebra.dot-Tuple{HighPrecisionVector, HighPrecisionVector}","page":"API","title":"LinearAlgebra.dot","text":"LinearAlgebra.dot(v1::HighPrecisionVector, v2::HighPrecisionVector)\n\nCalculates the dot product of two vectors. Both vectors must have the same length. This function extends LinearAlgebra.dot. The multiplication and summation are performed using BigInt intermediates to avoid repeated HighPrecisionInt object creation during summation.\n\n\n\n\n\n","category":"method"},{"location":"api/high-precision-arithmetic/#HighPrecisionArithmetic.@hpi_str-Tuple{String}","page":"API","title":"HighPrecisionArithmetic.@hpi_str","text":"@hpi_str(s::String)\n\nA string macro that creates a HighPrecisionInt from a string literal.\n\nExamples\n\njulia> hpi\"12345678901234567890\"\nHighPrecisionInt(12345678901234567890, coeffs=[124989312, 688091136, 166])\n\njulia> hpi\"-0xABCDEF\"\nHighPrecisionInt(-11259375, coeffs=[11259375])\n\n\n\n\n\n","category":"macro"},{"location":"HighPrecisionInteger/#High-Precision-Number","page":"High Precision Integer","title":"🔢 High Precision Number","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"This module introduces HighPrecisionInt, a custom type for arbitrary-precision integer arithmetic, exceeding standard limits like Int64 or UInt128.","category":"page"},{"location":"HighPrecisionInteger/#Definitions","page":"High Precision Integer","title":"📘 Definitions","text":"","category":"section"},{"location":"HighPrecisionInteger/#HIGH*PRECISION*BASE","page":"High Precision Integer","title":"HIGHPRECISIONBASE","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"const HIGH_PRECISION_BASE = UInt64(2)^32","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Defines the base B = 2^32 used for arithmetic, where each UInt64 coefficient holds a 32-bit \"digit\", leaving  the upper 32 bits for intermediate calculations without overflow before normalization. ","category":"page"},{"location":"HighPrecisionInteger/#HighPrecisionInt","page":"High Precision Integer","title":"HighPrecisionInt","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"The core of the module is the HighPrecisionInt struct. It represents numbers as a vector of coeffs::Vector{UInt64} coefficients, effectively \"digits\" in base HIGH_PRECISION_BASE, along with a sign::Int8 sign.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"mutable struct HighPrecisionInt\n    coeffs::Vector{UInt64} # Coefficients in little-endian order\n    sign::Int8              # 1 (positive), -1 (negative), 0 (zero)\nend","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Mathematically, a HighPrecisionInt N is represented as:","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"N = textsign times sum_i=1^textlength(coeffs) textcoeffsi cdot B^i-1","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"where B is the HIGH_PRECISION_BASE, with coefficients coeffs stored in little-endian order.","category":"page"},{"location":"HighPrecisionInteger/#Key-Functions-and-Operators","page":"High Precision Integer","title":"➕ Key Functions and Operators","text":"","category":"section"},{"location":"HighPrecisionInteger/#Constructors","page":"High Precision Integer","title":"🧱 Constructors","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"You can create a HighPrecisionInt in several ways:","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"From coefficients and sign: \nHighPrecisionInt(coeffs::Vector{UInt64}, sign::Int8=1)  \nCreates a HighPrecisionInt using a coefficient vector and optional sign, applying normalize! to maintain canonical form.\nUsage\njulia> hpi_basic = HighPrecisionInt([UInt64(123)])\nHighPrecisionInt(123, coeffs=[123])\n\njulia> hpi_zero = HighPrecisionInt([UInt64(0)])\nHighPrecisionInt(0, coeffs=[])\n\njulia> hpi_negative = HighPrecisionInt([UInt64(100)], Int8(-1))\nHighPrecisionInt(-100, coeffs=[100])\n\njulia> hpi_large = HighPrecisionInt([UInt64(1), UInt64(5), UInt64(1)])\nHighPrecisionInt(21474836481, coeffs=[1, 5, 1])\nFrom Julia Integer or BigInt:\nHighPrecisionInt(x::T) where {T<:Union{Integer, BigInt}}\nConverts a Julia Integer or BigInt into a HighPrecisionInt, the primary and most convenient method for creating high-precision numbers from built-in types.\njulia> hpi_int = HighPrecisionInt(123)\nHighPrecisionInt(123, coeffs=[123])\n\njulia> hpi_neg_int = HighPrecisionInt(-4567)\nHighPrecisionInt(-4567, coeffs=[4567])\n\njulia> hpi_zero_int = HighPrecisionInt(0)\nHighPrecisionInt(0, coeffs=[])\n\njulia> val_big = HighPrecisionInt(BigInt(2)^76 - 1)\nHighPrecisionInt(18446744073709551615, coeffs=[4294967295, 4294967295, 4095])\n\njulia> val_big_neg = HighPrecisionInt(-BigInt(2)^92 - 1)\nHighPrecisionInt(-1, coeffs=[1, 0, 268435456])","category":"page"},{"location":"HighPrecisionInteger/#Internal-Utilities","page":"High Precision Integer","title":"🛠️ Internal Utilities","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"normalize!(hpi::HighPrecisionInt)\nEnsures canonical form by handling carries (0 le c_i  B), removing leading zeros, and setting the correct sign (especially for zero). This function is called automatically by the HighPrecisionInt constructors and other operations to maintain canonical form.","category":"page"},{"location":"HighPrecisionInteger/#Conversions","page":"High Precision Integer","title":"🔁 Conversions","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Base.BigInt(hpi::HighPrecisionInt)\nConverts hpi::HighPrecisionInt value to a bi::BigInt using \ntextbi = texthpisign times sum texthpicoeff_i cdot B^i-1\nuseful for verification or interoperability with libraries that use BigInt.\nUsage\njulia> hpi_val = HighPrecisionInt(12345678901234567890)\nHighPrecisionInt(12345678901234567890, coeffs=[3944680146, 2874452364])\n\njulia> bi_val = BigInt(hpi_val)\n12345678901234567890\n\njulia> hpi_neg = HighPrecisionInt(-BigInt(2)^70)\nHighPrecisionInt(0, coeffs=[0, 0, 64])\n\njulia> bi_neg = BigInt(hpi_neg)\n0\n\njulia> hpi_zero = HighPrecisionInt(0)\nHighPrecisionInt(0, coeffs=[])\n\njulia> bi_zero = BigInt(hpi_zero)\n0","category":"page"},{"location":"HighPrecisionInteger/#Unary-Operations","page":"High Precision Integer","title":"🔄 Unary Operations","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Base.abs(hpi::HighPrecisionInt):   Returns the absolute value of a HighPrecisionInt.\nUsage\njulia> abs(HighPrecisionInt(123))\nHighPrecisionInt(123, coeffs=[123])\n\njulia> abs(HighPrecisionInt(-456))\nHighPrecisionInt(456, coeffs=[456])\n\njulia> abs(HighPrecisionInt(0))\nHighPrecisionInt(0, coeffs=[])\nBase.:-(hpi::HighPrecisionInt):   Unary negation; flips hpi.sign.\nUsage\njulia> -HighPrecisionInt(100)\nHighPrecisionInt(-100, coeffs=[100])\n\njulia> -HighPrecisionInt(-200)\nHighPrecisionInt(200, coeffs=[200])\n\njulia> -HighPrecisionInt(0)\nHighPrecisionInt(0, coeffs=[])","category":"page"},{"location":"HighPrecisionInteger/#Comparison-Operators","page":"High Precision Integer","title":"⚖️ Comparison Operators","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Base.isequal(a::HighPrecisionInt, b::HighPrecisionInt)\nChecks if two HighPrecisionInt instances are equal. Also aliased by Base.:(==).\nUsage\njulia> HighPrecisionInt(10) == HighPrecisionInt(10)\ntrue\n\njulia> HighPrecisionInt(10) == HighPrecisionInt(20)\nfalse\n\njulia> HighPrecisionInt(0) == HighPrecisionInt(-0)\ntrue\n\njulia> HighPrecisionInt(BigInt(2)^54 + 2) == HighPrecisionInt(2^53 + 2^53 + 2)\ntrue\n\njulia> HighPrecisionInt(BigInt(2)^154 + 2) == HighPrecisionInt(4*BigInt(2)^151 + BigInt(2)^153 + 2)\ntrue\n\njulia> HighPrecisionInt(BigInt(1000000000000)) == HighPrecisionInt(1000000000000)\ntrue\nBase.isless(a::HighPrecisionInt, b::HighPrecisionInt)\nChecks if a is strictly less than b. Also aliased by Base.:(<).\nUsage\njulia> HighPrecisionInt(5) < HighPrecisionInt(10)\ntrue\n\njulia> HighPrecisionInt(10) < HighPrecisionInt(-5)\nfalse\n\njulia> HighPrecisionInt(0) < HighPrecisionInt(0)\nfalse\n\njulia> HighPrecisionInt(BigInt(2)^73) < HighPrecisionInt(-10)\nfalse\n\njulia> HighPrecisionInt(BigInt(2)^112) < HighPrecisionInt(BigInt(2)^111)\nfalse","category":"page"},{"location":"HighPrecisionInteger/#Arithmetic-Operators","page":"High Precision Integer","title":"🧮 Arithmetic Operators","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"All arithmetic operations correctly handle signs and normalize results.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Addition:","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Base.:+(a::HighPrecisionInt, b::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Adds a and b. ","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"If signs are the same, magnitudes are added with carry. If signs differ, it computes pm (a - b) using abs_subtract.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Usage","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"```jldoctest   julia> HighPrecisionInt(1000) + HighPrecisionInt(2000)   HighPrecisionInt(3000, coeffs=[3000])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> HighPrecisionInt(-1000) + HighPrecisionInt(-2000)   HighPrecisionInt(-3000, coeffs=[3000])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> hpi_large = HighPrecisionInt(BigInt(98765432109876543210987654321098765))   HighPrecisionInt(5549898291852431373, coeffs=[2171162637, 1292186391, 46642767, 1246595])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> hpi_small = HighPrecisionInt(-12345)   HighPrecisionInt(-12345, coeffs=[12345])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> hpilarge + hpismall   HighPrecisionInt(98765432109876543210987654320986420, coeffs=[3102421704, 2874136453, 2874136453, 2874136453, 2874136453, 229])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> hpi_small = HighPrecisionInt(12345)   HighPrecisionInt(12345, coeffs=[12345])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> hpismall + hpilarge    HighPrecisionInt(98765432109876543210987654321101009, coeffs=[3102446385, 2874136453, 2874136453, 2874136453, 2874136453, 229])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> HighPrecisionInt(BigInt(2)^34+1) + HighPrecisionInt(-3*BigInt(2)^31+1)   HighPrecisionInt(0, coeffs=[])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> HighPrecisionInt(123) + HighPrecisionInt(0)   HighPrecisionInt(123, coeffs=[123])   ```","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Subtract:\nBase.:-(a::HighPrecisionInt, b::HighPrecisionInt) \nSubtracts b from a; implemented as a + (-b).\nUsage\njulia> HighPrecisionInt(1000) - HighPrecisionInt(2000)\nHighPrecisionInt(-1000, coeffs=[1000])\n\njulia> HighPrecisionInt(-1000) - HighPrecisionInt(-2000)\nHighPrecisionInt(1000, coeffs=[1000])\n\njulia> hpi_large = HighPrecisionInt(BigInt(98765432109876543210987654321098765))\nHighPrecisionInt(5549898291852431373, coeffs=[2171162637, 1292186391, 46642767, 1246595])\n\njulia> hpi_small = HighPrecisionInt(12345)\nHighPrecisionInt(12345, coeffs=[12345])\n\njulia> hpi_large - hpi_small\nHighPrecisionInt(5549898291852419028, coeffs=[2171150292, 1292186391, 46642767, 1246595])\n\njulia> hpi_small - hpi_large\nHighPrecisionInt(-5549898291852419028, coeffs=[2171150292, 1292186391, 46642767, 1246595])\n\njulia> HighPrecisionInt(BigInt(2)^34+1) - HighPrecisionInt(3*BigInt(2)^31+1)\nHighPrecisionInt(10737418240, coeffs=[2147483648, 2])\n\njulia> HighPrecisionInt(123) - HighPrecisionInt(0)\nHighPrecisionInt(123, coeffs=[123])\nMultiplication:\nBase.:*(a::HighPrecisionInt, b::HighPrecisionInt)  \nMultiplies a and b using long multiplication in base B. Partial products a_i cdot b_j are accumulated with carry propagation.\na cdot b = sum_k=1^textlen_a sum_l=1^textlen_b (a_k cdot b_l) cdot B^k+l-2\nUsage\njulia> HighPrecisionInt(15) * HighPrecisionInt(8)\nHighPrecisionInt(120, coeffs=[120])\n\njulia> HighPrecisionInt(15) * HighPrecisionInt(-8)\nHighPrecisionInt(-120, coeffs=[120])\n\njulia> HighPrecisionInt(123) * HighPrecisionInt(0)\nHighPrecisionInt(0, coeffs=[])\n\njulia> hpi_large_1 = HighPrecisionInt(BigInt(123456789012345))\nHighPrecisionInt(123456789012345, coeffs=[2249056121, 28744])\n\njulia> hpi_large_2 = HighPrecisionInt(BigInt(987654321098765))\nHighPrecisionInt(987654321098765, coeffs=[821579789, 229956])\n\njulia> hpi_large_1 * hpi_large_2\nHighPrecisionInt(14417890538969770277, coeffs=[1371679013, 3356926734, 2315013882, 1])\n\njulia> hpi_large_3 = HighPrecisionInt(BigInt(12345678901234567890123))\nHighPrecisionInt(4807115922877859019, coeffs=[1900168395, 1119243894, 669])\n\njulia> hpi_large_4 = HighPrecisionInt(-BigInt(98765432109876543210987))\nHighPrecisionInt(-1564339235603858923, coeffs=[509593067, 364226111, 5354])\n\njulia> hpi_large_3 * hpi_large_4\nHighPrecisionInt(-12206592816479624537, coeffs=[1209687385, 2842068862, 4008437551, 4196447926, 3583277])","category":"page"},{"location":"HighPrecisionInteger/#Macros","page":"High Precision Integer","title":"🧩 Macros","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"@hpi_str(s::String)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Constructs a HighPrecisionInt from a string literal s (decimal or \"0x\" prefixed hex).\nUsage\njulia> hpi\"12345678901234567890\"\nHighPrecisionInt(12345678901234567890, coeffs=[3944680146, 2874452364])\n\njulia> hpi\"-0xABCDEF\"\nHighPrecisionInt(-11259375, coeffs=[11259375])\n\njulia> hpi\"1234567890123456789012345678901234567890\"\nHighPrecisionInt(12446928571455179474, coeffs=[3460238034, 2898026390, 3235640248, 2697535605, 3])","category":"page"},{"location":"HighPrecisionInteger/#Display","page":"High Precision Integer","title":"🖥️ Display","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Base.show(io::IO, hpi::HighPrecisionInt)","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Defines how HighPrecisionInt are displayed when printed, showing their equivalent decimal value and coefficients in little-endian order. ","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"Usage","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"```jldoctest   julia> hpi_1 = HighPrecisionInt(99999999999999999999)   HighPrecisionInt(99999999999999999999, coeffs=[1775798783, 1260799867, 23])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> hpi_2 = HighPrecisionInt(-1234567890)   HighPrecisionInt(-1234567890, coeffs=[1234567890])","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"julia> hpi_3 = HighPrecisionInt(0)   HighPrecisionInt(0, coeffs=[0])   ```","category":"page"},{"location":"HighPrecisionInteger/#Verification-Examples","page":"High Precision Integer","title":"🧪 Verification Examples","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"To ensure the correctness of the HighPrecisionInt , the following examples demonstrate various operations and verify their results against Julia's built-in BigInt type.","category":"page"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"```julia   using HighPrecisionArithmetic","category":"page"},{"location":"HighPrecisionInteger/#1.-Creation-and-Conversion-Verification","page":"High Precision Integer","title":"1. Creation and Conversion Verification","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"BigInt(HighPrecisionInt(typemax(UInt128))) == typemax(UInt128)   BigInt(HighPrecisionInt(-BigInt(2)^150 - 1)) == (-BigInt(2)^150 - 1)","category":"page"},{"location":"HighPrecisionInteger/#2.-Addition-Verification","page":"High Precision Integer","title":"2. Addition Verification","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"BigInt(HighPrecisionInt(1000) + HighPrecisionInt(2000)) == 3000   BigInt(HighPrecisionInt(-1000) + HighPrecisionInt(-2000)) == -3000   expectedsumdiffsignspos = BigInt(98765432109876543210987654321098765) - BigInt(12345)   BigInt(HighPrecisionInt(BigInt(98765432109876543210987654321098765)) + HighPrecisionInt(-BigInt(12345))) == expectedsumdiffsignspos   expectedsumdiffsignsneg = BigInt(12345) - BigInt(98765432109876543210987654321098765)   BigInt(HighPrecisionInt(BigInt(12345)) + HighPrecisionInt(-BigInt(98765432109876543210987654321098765))) == expectedsumdiffsignsneg","category":"page"},{"location":"HighPrecisionInteger/#3.-Subtraction-Verification","page":"High Precision Integer","title":"3. Subtraction Verification","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"BigInt(HighPrecisionInt(5000) - HighPrecisionInt(2000)) == 3000   BigInt(HighPrecisionInt(2000) - HighPrecisionInt(5000)) == -3000","category":"page"},{"location":"HighPrecisionInteger/#4.-Multiplication-Verification","page":"High Precision Integer","title":"4. Multiplication Verification","text":"","category":"section"},{"location":"HighPrecisionInteger/","page":"High Precision Integer","title":"High Precision Integer","text":"BigInt(HighPrecisionInt(15) * HighPrecisionInt(8)) == 120   BigInt(HighPrecisionInt(-15) * HighPrecisionInt(8)) == -120   expectedproductlargesigned = BigInt(12345678901234567890123) * -BigInt(98765432109876543210987)   BigInt(HighPrecisionInt(BigInt(12345678901234567890123)) * HighPrecisionInt(-BigInt(98765432109876543210987))) == expectedproductlargesigned   ```","category":"page"},{"location":"HighPrecisionLinearAlgebra/#High-Precision-Linear-Algebra","page":"High Precision Linear Algebra","title":"🧮 High Precision Linear Algebra","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"This module extends the functionality of HighPrecisionNumber by providing basic linear algebra operations for vectors and matrices using HighPrecisionInt elements. It enables computations with arbitrary-precision numbers in vector and matrix contexts.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Dependencies","page":"High Precision Linear Algebra","title":"📦 Dependencies","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"HighPrecisionNumber: Provides the HighPrecisionInt type.\nLinearAlgebra (Base): Required for defining and overloading operations like dot.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Type-Definitions","page":"High Precision Linear Algebra","title":"🔧 Type Definitions","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/#HighPrecisionVector","page":"High Precision Linear Algebra","title":"📐 HighPrecisionVector","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"Represents a high-precision vector.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"mutable struct HighPrecisionVector\n    elements::Vector{HighPrecisionInt}\nend","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Constructors:","page":"High Precision Linear Algebra","title":"🛠️ Constructors:","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"HighPrecisionVector(elements::Vector{HighPrecisionInt})   From high-precision elements.\nHighPrecisionVector(elements::Vector{T}) where {T<:Union{Integer, BigInt}}   Automatically converts standard integers to HighPrecisionInt.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#HighPrecisionMatrix","page":"High Precision Linear Algebra","title":"🧱 HighPrecisionMatrix","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"Represents a high-precision matrix.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"mutable struct HighPrecisionMatrix\n    elements::Vector{Vector{HighPrecisionInt}}\n    rows::Int\n    cols::Int\nend","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Constructors:-2","page":"High Precision Linear Algebra","title":"🛠️ Constructors:","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"HighPrecisionMatrix(elements::Vector{Vector{HighPrecisionInt}})   Validates consistent column lengths.\nHighPrecisionMatrix(elements::Vector{Vector{T}}) where {T<:Union{Integer, BigInt}}   Converts integers to HighPrecisionInt.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Operator-Overloads-and-Functions","page":"High Precision Linear Algebra","title":"➕ Operator Overloads and Functions","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/#Vector-Operations","page":"High Precision Linear Algebra","title":"📏 Vector Operations","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"Base.:+(v1::HighPrecisionVector, v2::HighPrecisionVector)\nBase.:-(v1::HighPrecisionVector, v2::HighPrecisionVector)\nBase.:*(scalar::Union{Integer, BigInt, HighPrecisionInt}, v::HighPrecisionVector)\nBase.:*(v::HighPrecisionVector, scalar::Union{Integer, BigInt, HighPrecisionInt})\nLinearAlgebra.dot(v1::HighPrecisionVector, v2::HighPrecisionVector)","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"ℹ️ dot uses BigInt internally for accumulation and returns a HighPrecisionInt.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Matrix-Operations","page":"High Precision Linear Algebra","title":"🧮 Matrix Operations","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"Base.:+(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)\nBase.:-(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)\nBase.:*(scalar, m::HighPrecisionMatrix)\nBase.:*(m::HighPrecisionMatrix, scalar)\nBase.:*(m::HighPrecisionMatrix, v::HighPrecisionVector)\nBase.:*(m1::HighPrecisionMatrix, m2::HighPrecisionMatrix)","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"ℹ️ Internally uses BigInt for intermediate results to ensure precision.","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Display-Methods","page":"High Precision Linear Algebra","title":"🖨️ Display Methods","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"Base.show(io::IO, v::HighPrecisionVector)\nBase.show(io::IO, m::HighPrecisionMatrix)","category":"page"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"","category":"page"},{"location":"HighPrecisionLinearAlgebra/#Usage-Examples","page":"High Precision Linear Algebra","title":"🧪 Usage Examples","text":"","category":"section"},{"location":"HighPrecisionLinearAlgebra/","page":"High Precision Linear Algebra","title":"High Precision Linear Algebra","text":"# 📥 Include required modules\ninclude(\"HighPrecisionNumber.jl\")\ninclude(\"HighPrecisionLinearAlgebra.jl\")\nusing .HighPrecisionLinearAlgebra\nusing .HighPrecisionNumber\n\nprintln(\"--- HighPrecisionLinearAlgebra Usage Examples ---\")\n\n# 1️⃣ HighPrecisionVector Creation\nvec1 = HighPrecisionVector([1, -2])\nvec2 = HighPrecisionVector([1000, -500, 200])\nlarge_vec = HighPrecisionVector([BigInt(2)^70, -BigInt(2)^75, BigInt(2)^80])\n\n# 2️⃣ Vector Addition & Subtraction\nvec1_compat = HighPrecisionVector([1, 2, 3])\nvec2_compat = HighPrecisionVector([10, 20, 30])\nv_sum = vec1_compat + vec2_compat\nv_diff = vec1_compat - vec2_compat\n\n# 3️⃣ Scalar Multiplication\nscalar_val = HighPrecisionInt(5)\nv_scaled = scalar_val * HighPrecisionVector([1, -2, 3])\n\n# 4️⃣ Dot Product\ndot_vec_a = HighPrecisionVector([1, 2, 3])\ndot_vec_b = HighPrecisionVector([4, 5, 6])\nv_dot = LinearAlgebra.dot(dot_vec_a, dot_vec_b)\n\n# 5️⃣ Matrix Creation\nmat1 = HighPrecisionMatrix([[1, 2], [3, 4]])\nmat2 = HighPrecisionMatrix([[5, 6], [7, 8]])\nlarge_mat = HighPrecisionMatrix([\n    [BigInt(2)^60, -BigInt(2)^62],\n    [BigInt(2)^65, BigInt(2)^67]\n])\n\n# 6️⃣ Matrix Addition & Subtraction\nm_sum = mat1 + mat2\nm_diff = mat1 - mat2\n\n# 7️⃣ Matrix Scalar Multiplication\nm_scaled = HighPrecisionInt(3) * mat1\n\n# 8️⃣ Matrix-Vector Multiplication\nm_vec_prod = mat1 * vec1\n\n# 9️⃣ Matrix-Matrix Multiplication\nm_mat_prod = mat1 * mat2\n\n# 🖨️ Display Results\nprintln(\"vec1 = $vec1\")\nprintln(\"vec2 = $vec2\")\nprintln(\"large_vec = $large_vec\")\nprintln(\"v_sum = $v_sum\")\nprintln(\"v_diff = $v_diff\")\nprintln(\"v_scaled = $v_scaled\")\nprintln(\"v_dot = $v_dot\")\nprintln(\"mat1 = \\n$mat1\")\nprintln(\"mat2 = \\n$mat2\")\nprintln(\"large_mat = \\n$large_mat\")\nprintln(\"m_sum = \\n$m_sum\")\nprintln(\"m_diff = \\n$m_diff\")\nprintln(\"m_scaled = \\n$m_scaled\")\nprintln(\"m_vec_prod = $m_vec_prod\")\nprintln(\"m_mat_prod = \\n$m_mat_prod\")\n\nprintln(\"\\n--- ✅ End of Examples ---\")","category":"page"},{"location":"#High-Precision-Arithmetic-Library","page":"Home","title":"High Precision Arithmetic Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for the High Precision Arithmetic Library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This library provides arbitrary-precision arithmetic and linear algebra operations built on top of it.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High Precision Integer\nHigh Precision Linear Algebra","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High Precision Arithmetic API","category":"page"}]
}
